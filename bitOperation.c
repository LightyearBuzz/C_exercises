//Упражнения, побитовые операции. Рассмотрим побочные эффекты от операций
#include <stdio.h>

void binaryPrint(unsigned char value);

int main(void)
{
	/////////////1.ИЛИ
	//позволяет устанавливать заданный бит в числе.
	//ASCII код прописной буквы "А" - 65, код строчной "а" - 97.
	//то есть если установить шестой бит(32) в числе 65, оно станет равно 97.
	//"А" превратиться в "а". Для это используем побитовое ИЛИ:
	unsigned char letter_A = 65;//буква 'А', в двоичной               0100 0001
	unsigned char mask = 32;//маска содержит установленный шестой бит 0010 0000
	unsigned char letter_a = letter_A | mask;//с помощью побитового ИЛИ установим шестой бит
												//("А" превратиться в "а")
	
	printf("OR\n");
	binaryPrint(letter_A);//выводим значение в двоичной системе
	printf(" %c\n", letter_A);
	binaryPrint(letter_a);//выводим значение в двоичной системе
	printf(" %c\n\n", letter_a);


	/////////////2.И
	//позволяет снимать заданный бит в числе и проверять установлен ли бит.
	//теперь снимем шестой бит в строчной "а" и получим "А". Для этого используем 
	//побитовую операцию И с маской в которой все биты - 1, а шестой - 0(223)
	mask = 223; //маска содержит шестой бит в 0   1101 1111
	letter_A = letter_a & mask;//снимаем шестой бит
	printf("AND\n");
	binaryPrint(letter_A);//выводит значение в двоичной системе
	printf(" %c\n\n", letter_A);


	/////////////3.ИСКЛЮЧАЮЩЕЕ ИЛИ
	//позволяет защифровать нужную информацию
	//возмем букву А, и применим к ней ИСКЛЮЧАЮЩЕЕ ИЛИ,
	//в качестве ключа шифрования используем число 110.
	letter_A = 'A';
	unsigned char key = 110;//ключ шифрования
	unsigned char kode = letter_A ^ key;//шифруем применяя ключ
	printf("XOR\n");
	printf("%c    ", letter_A);
	binaryPrint(letter_A);//выводит значение А в двоичной системе
	printf("\n");
	printf("key  ");
	binaryPrint(key);//выводит значение key в двоичной системе
	printf("\n");
	printf("kode ");
	binaryPrint(kode);//выводит значение kode в двоичной системе
	printf("\n");
	kode = kode ^ key;//расшифровываем применяя ключ
	printf("%c    ", kode);
	binaryPrint(kode);//выводит значение kode в двоичной системе
	printf("\n\n");


	/////////////4.НЕ
	//побитовое НЕ позволяет инвертировать(переключить) все биты в числе
	//возмем число 65 (0100 0001), если применить побитовое НЕ,
	//мы получим число(1011 1110)
	printf("NOT\n");
	binaryPrint(letter_A);
	printf("\n");
	letter_A = ~letter_A;//инверсия с помощью НЕ
	binaryPrint(letter_A);
	printf("\n\n");


	/////////////5.<<
	//побитовый сдвиг влево. с его помощью можно производить умножение
	//возмем число 5 и применим сдвиг влево на 1 разряд, тк система двоичная
	//мы получим умножение на два
	unsigned char multiplier = 5;
	mask = 1;//маска сдвига равна 1
	unsigned char product = multiplier << mask;//сдвиг на один байт влево
	printf("<<\n");
	printf("%d   ", multiplier);//выводит множитель
	binaryPrint(multiplier);//выводит двоичное представление множителя
	printf("\n");
	printf("%d  ", product);//выводит произведение 
	binaryPrint(product);//выводит двоичное представление произведения
	printf("\n\n");


	/////////////6.>>
	//побитовый сдвиг вправо. с его помощью можно производить деление
	//возьмем число 10 и применим сдвиг вправо на один разряд, тк система двоичная
	//мы получим деление на два
	unsigned char dividend = 10;
	mask = 1;//маска сдвига равна 1
	unsigned char result = dividend >> mask;//сдвиг на 1 байт влево
	printf(">>\n");
	printf("%d  ", dividend);//выводит делимое
	binaryPrint(dividend);//выводит двоичное представление делимого
	printf("\n");
	printf("%d   ", result);//выводит резултат
	binaryPrint(result);//выводит двоичное представление произведения
	printf("\n");

	return 0;
}


//принимает число и выводит его на консоль в двоичной системе счисления 
void binaryPrint(unsigned char value)
{
	for(unsigned char x = 128; x > 0; x = x/2)
	{
		if( (value & x) != 0 )
		{
			printf("1");
		}else
		{
			printf("0");
		}
	}
}